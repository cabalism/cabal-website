<!DOCTYPE html>
<html lang="en" data-bs-theme="light">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="title" content="Cabal">
<meta name="description" content="Build Haskell applications and libraries">

    <title>Cabal</title>
    <script src="./js/bootstrap.min.js"></script>
    <script src="./js/popper.min.js"></script>
    <link rel="stylesheet" type="text/css" href="./css/app.css" />
    <link href="./images/Cabal-tiny.png" rel="icon">

</head>

<body>
    <div class="d-lg-none">
        <div id="nav-top" class="d-print-none">
            <nav>
    <ul class="nav">
        <li class="nav-item"><a class="nav-link" href="./">~/</a></li>
        <li class="nav-item"><a class="nav-link" href="http://cabal.readthedocs.io/en/latest/" target="_blank">docs</a></li>
        <li class="nav-item"><a class="nav-link" href="./pages/download.html">download</a></li>
        <li class="nav-item"><a class="nav-link" href="./releases/">releases</a></li>
        <li class="nav-item"><a class="nav-link" href="./pages/faq.html">FAQ</a></li>
        <li class="nav-item"><a class="nav-link" href="./blog/">blog</a></li>
        <li class="nav-item"><a class="nav-link" href="./pages/history.html">history</a></li>
    </ul>
</nav>

        </div>
        <div id="content" class="d-print-col-12">
            <h2 id="introduction">Introduction</h2>
<p>Cabal is an acronym of <strong>C</strong>ommon <strong>A</strong>rchitecture for <strong>B</strong>uilding
<strong>A</strong>pplications and <strong>L</strong>ibraries. Central to this architecture is <code>cabal</code>, the
executable (exe) build tool from the <a href="https://hackage.haskell.org/package/cabal-install">cabal-install</a> package.</p>
<div class="info">
<p>This architecture defines a common interface for package authors and
distributors to easily build their applications in a portable way. It is part of
a larger infrastructure for distributing, organizing, and cataloging Haskell
libraries and programs. Specifically, it describes what a package is, how these
interact with the language, and what Haskell implementations (compilers) must to
do to support packages. It also specifies some infrastructure (code) that makes
it easy for tool authors to build and distribute conforming packages.</p>
</div>
<p>Here's an elided dump of <code>cabal --help</code> showing the fundamental commands:</p>
<pre class="shell"><code>$ cabal --help
Command line interface to the Haskell Cabal infrastructure.

Commands:
 [initialization and download]
  init                   Create a new cabal package.

 [project building and installing]
  build                  Compile targets within the project.
  clean                  Clean the package store and remove temporary files.

 [running and testing]
  repl                   Open an interactive session for the given component.
  run                    Run an executable.
  test                   Run test-suites.

 [sanity checks and shipping]
  sdist                  Generate a source distribution file (.tar.gz).</code></pre>
<div class="warning">
<p>The architecture says nothing about more global issues such as how authors
decide where in the module name space their library should live; how users can
find a package they want; how orphan packages find new owners; and so on.</p>
</div>
<h2 id="packages">Packages</h2>
<p>When developing anything non-trivial in Haskell, anything that larger than a
single <code>.hs</code> file, we pack modules (<code>.hs</code> files) into packages.</p>
<ul>
<li><strong>Module</strong> - The unit of compilation in Haskell is the module. A module is a
collection of related functions, types, and type classes. Modules are the
primary unit of organization in Haskell programs.</li>
<li><strong>Package</strong> - The unit of distribution in Haskell is the package. A package is
a collection of one or more modules, plus some metadata about the package
(e.g., its name, version, and dependencies). Package components include
libraries, executables, test suites and benchmarks.</li>
</ul>
<p>Package source code can be published to Hackage and vetted by Stackage.</p>
<ul>
<li><p><strong>Hackage</strong> - A central repository of Haskell packages. Hackage is a website
that hosts packages and provides tools for searching, browsing, and
downloading packages.</p></li>
<li><p><strong>Stackage</strong> - For each resolver Stackage pairs a GHC compiler version with a
groups of packages from Hackage that build together. This group is pins each
included package to an exact version.</p>
<p>Stackage resolvers come in three sets; <code>nightly-yyyy-mm-dd</code> for the latest
set, <code>lts-mm.nn</code> for stable packages and <code>ghc</code> for the very limited set of
packages released with GHC. Each <code>lts-mm.*</code> series imposes some rules on
included packages, such as not allowing breaking version bumps.</p></li>
</ul>
<h2 id="demo">Demo</h2>
<p>Having installed <code>GHC</code> and <code>cabal</code> with <a href="https://www.haskell.org/ghcup/">GHCup</a> on Ubuntu Linux, let's
find <code>cabal</code>;</p>
<pre class="shell"><code>$ type cabal
cabal is ~/.ghcup/bin/cabal

$ readlink ~/.ghcup/bin/cabal
cabal-3.10.3.0

$ type cabal-3.10.3.0
cabal-3.10.3.0 is ~/.ghcup/bin/cabal-3.10.3.0</code></pre>
<p>We can use <code>cabal</code> to download its own package, <code>cabal-install</code>, from Hackage.</p>
<div class="info">
<p>A package is its description, in a <code>.cabal</code> file, and all of the source referred
to by that description. The package description file name must be the same as
the name of the package. An <code>sdist</code> is a <code>.tar.gz</code> archive of a package.</p>
</div>
<pre class="shell"><code>$ VER=3.10.3.0 cabal get cabal-install-{$VER}
Downloading  cabal-install-3.10.3.0
Downloaded   cabal-install-3.10.3.0
Unpacking to cabal-install-3.10.3.0/

$ VER=3.10.3.0 cat cabal-install-{$VER}/cabal-install.cabal
Cabal-Version:      2.2
Name:               cabal-install
Version:            3.10.3.0
...
executable cabal
...</code></pre>
<p>We can install <code>cabal</code> it again<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, showing that <code>cabal</code> can build and install
local packages from source and when doing so downloads dependencies from
Hackage, in this case <code>cabal-install-solver</code> and <code>hackage-security</code>.</p>
<div class="info">
<p>We can (and oftentimes must) use <a href="https://cabal.readthedocs.io/en/latest/cabal-commands.html#target-forms">targets</a> to specify some or all
of the components of a package. Many <code>cabal</code> build tool commands require a
target and in fact, <code>cabal build</code> will fail if not given a target.</p>
<ul>
<li>The <code>all</code> target includes every component.</li>
<li>The <code>all:ctype</code> target includes every component of a certain component type
(<code>ctype</code>), such as <code>libs</code>, <code>exes</code> and <code>tests</code>.</li>
<li><code>cabal-install:exe:cabal</code> is a fully qualified name for <code>cabal</code>, as an <code>exe</code>
component of the <code>cabal-install</code> package.</li>
</ul>
</div>
<pre class="shell"><code>$ cd cabal-install-3.10.3.0/

$ cabal install cabal-install:exe:cabal --overwrite-policy=always
Wrote tarball sdist to
/.../cabal-install-3.10.3.0/dist-newstyle/sdist/cabal-install-3.10.3.0.tar.gz
Resolving dependencies...
Build profile: -w ghc-9.8.2 -O1
In order, the following will be built (use -v for more details):
 - cabal-install-solver-3.10.3.0 (lib) (requires download &amp; build)
 - hackage-security-0.6.2.6 (lib) (requires build)
 - cabal-install-3.10.3.0 (lib) (requires build)
 - cabal-install-3.10.3.0 (exe:cabal) (requires build)
Downloading  cabal-install-solver-3.10.3.0
Starting     hackage-security-0.6.2.6 (lib)
Downloaded   cabal-install-solver-3.10.3.0
Starting     cabal-install-solver-3.10.3.0 (lib)
Building     hackage-security-0.6.2.6 (lib)
Building     cabal-install-solver-3.10.3.0 (lib)
Installing   hackage-security-0.6.2.6 (lib)
Completed    hackage-security-0.6.2.6 (lib)
Installing   cabal-install-solver-3.10.3.0 (lib)
Completed    cabal-install-solver-3.10.3.0 (lib)
Starting     cabal-install-3.10.3.0 (lib)
Building     cabal-install-3.10.3.0 (lib)
Installing   cabal-install-3.10.3.0 (lib)
Completed    cabal-install-3.10.3.0 (lib)
Starting     cabal-install-3.10.3.0 (exe:cabal)
Building     cabal-install-3.10.3.0 (exe:cabal)
Installing   cabal-install-3.10.3.0 (exe:cabal)
Completed    cabal-install-3.10.3.0 (exe:cabal)
Symlinking 'cabal' to '~/.cabal/bin/cabal'</code></pre>
<div class="warning">
<p>There is currently no command to show the available targets, but <code>cabal targets</code>
has been proposed for this purpose with <a href="https://github.com/haskell/cabal/pull/9744">cabal#9744</a>.</p>
</div>
<h2 id="projects">Projects</h2>
<p>Even larger, projects are a collections of packages. These allow us to develop a
set of related packages, to develop a product and to depend on unpublished
packages that we can get from source code repositories or other means.</p>
<ul>
<li><strong>Source Code Repositories</strong> - It is possible to depend on packages that are
in a source code repository.</li>
<li><strong>Vendored Packages</strong> - When source code for a package is copied locally and
used if it was a local package.</li>
</ul>
<h2 id="building-with-stackage">Building with Stackage</h2>
<p>There are two main build tools in the Haskell ecosystem, Cabal and Stack with
exe names <code>cabal</code> and <code>stack</code>. The main difference between them is how they deal
with dependencies in their projects. Stack works with a Stackage resolver and
any dependency that is not included in the resolver must be pinned to an exact
version as an extra dependency. Cabal can work this way too but has a built-in
dependency solver that will pick versions of dependencies that are not pinned,
if it can.</p>
<p>Stack's project is a <code>.yaml</code> file and Cabal's is a <code>.project</code> file (by
convention). Each tools' command allows specifying alternate projects with
options, shown below specifying the default project names.</p>
<ul>
<li><code>--stack-yaml=stack.yaml</code></li>
<li><code>--project-file=cabal.project</code></li>
</ul>
<p>Both tools will pick up the project implicitly if it uses the default project
file name.</p>
<div class="info">
<p>Everything in a Stack project must be in the one file. That's a limitation of
<code>YAML</code>. The <code>.project</code> file format has no formal specification but uses the same
parser as the <code>.cabal</code> format that does, reusing some of the same fields as well
as having some fields specific to a project. The <code>import</code> field can be used to
import another project file configuration fragment and this is how Cabal can use
Stackage resolvers.</p>
<pre class="cabal"><code>import: https://www.stackage.org/nightly-2024-06-13/cabal.config</code></pre>
<pre class="shell"><code>$ curl -fsSL https://www.stackage.org/nightly-2024-06-13/cabal.config
...
with-compiler: ghc-9.8.2
constraints: abstract-deque ==0.3,
             abstract-deque-tests ==0.3,
             abstract-par ==0.3.3,
...
             zlib-clib ==1.3.1,
             zot ==0.0.3,
             zstd ==0.1.3.0</code></pre>
</div>
<div class="warning">
<p>While importing directly from Stackage may work, it can lead to unsolveable
version constraints. The way around this is to download the <code>cabal.config</code> from
Stackage for the resolver you want to use and then to comment out any
conflicting version constraints.</p>
</div>
<div class="warning">
<p>While Stack can work with Stackage <code>ghc-x.y.z</code> resolvers, no such resolver is
provided in <code>cabal.config</code> (cabal project) format.</p>
<pre class="shell"><code>$ curl -fsSL https://www.stackage.org/ghc-9.8.2/cabal.config
curl: (22) The requested URL returned error: 404</code></pre>
</div>
<h2 id="building-without-stackage">Building without Stackage</h2>
<p>A Cabal project can be set up without importing constraints from Stackage. If
you encounter constraint solver failures then picking a subset of a Stackage
resolvers' version constraints may help resolve the problem quicker than
fiddling with version choices and <code>allow-newer</code> exeptions until the constraint
solver is happy.</p>
<h2 id="extra-dependencies">Extra Dependencies</h2>
<p>Extra dependencies are a Stack concept that doesn't really exist in Cabal.
These are exact versions of packages that a project depends on that are not
included with the resolver in use (<code>snapshot</code> is a synonym of <code>resolver</code>). Here
are Stack's own extra dependencies:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">snapshot</span><span class="kw">:</span><span class="at"> lts-22.21</span><span class="co"> # GHC 9.6.5</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">extra-deps</span><span class="kw">:</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">  # lts-22.21 provides pantry-0.9.3.2.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> pantry-0.10.0@sha256:6f99ee8d7cfeeb0e2513638618acf80c72d018e7f10120048fa120a409b9dcd2,7864</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">  # lts-22.21 provides tar-0.5.1.1, which does not support Unicode filenames:</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> tar-0.6.2.0@sha256:619828cae098a7b6deeb0316e12f55011101d88f756787ed024ceedb81cf1eba,4576</span></span></code></pre></div>
<div class="info">
<p>If you're committing the <code>stack.yaml.lock</code> file then it is enough to leave off
the hash as the <code>.lock</code> file contains that detail. This way we can see that
Stack's <code>extra-deps</code> are exact version equality constraints.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">extra-deps</span><span class="kw">:</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> pantry-0.10.0</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> tar-0.6.2.0</span></span></code></pre></div>
</div>
<p>The same exact version equality constraints in a <code>cabal.project</code> would be:</p>
<pre class="cabal"><code>constraints:
    pantry ==0.10.0
  , tar ==0.6.2.0</code></pre>
<p>Stack needs these versions to be explicitly declared but Cabal will use its dependency
solver to fill in the gaps.</p>
<p>Whether using Stack or Cabal, the versions of dependencies needs to fit within
the version ranges for dependencies as specified in the <code>build-depends</code> field of
the package description. There is a way of relaxing the version constraints with
<code>--allow-newer</code> but this should only be used as a temporary workaround in order
to get a project to build. If there's a version range bound problem with a
dependency then you may fork it and fix the problem there (and hopefully
upstreaming the change) or you can ask the maintainer for a Hackage revision of
the package to relax an upper bound.</p>
<h2 id="source-dependencies">Source Dependencies</h2>
<p>From this snippet of a <code>cabal.project</code> for
<a href="https://github.com/up-do/unison/blob/add/updo/cabal.project">unison/cabal.project</a>, we can see that it is possible to
pull in dependencies from a source code repository (in addition to some version
constraints) with <code>source-repository-package</code> stanzas.</p>
<pre class="cabal"><code>import: ./project-stackage/lts-20.26.config

source-repository-package
  type: git
  location: https://github.com/unisonweb/configurator
  tag: e47e9e9fe1f576f8c835183b9def52d73c01327a
source-repository-package
  type: git
  location: https://github.com/unisonweb/haskeline
  tag: 9275eea7982dabbf47be2ba078ced669ae7ef3d5</code></pre>
<p>The Stack equivalent is very similar:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">resolver</span><span class="kw">:</span><span class="at"> lts-20.26</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">extra-deps</span><span class="kw">:</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">git</span><span class="kw">:</span><span class="at"> https://github.com/unisonweb/configurator</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> e47e9e9fe1f576f8c835183b9def52d73c01327a</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">git</span><span class="kw">:</span><span class="at"> https://github.com/unisonweb/haskeline</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> 9275eea7982dabbf47be2ba078ced669ae7ef3d5</span></span></code></pre></div>
<h2 id="package-and-description-generators">Package (and Description) Generators</h2>
<p>Starting with a blank slate, <code>cabal init</code> can be used to generate a skeleton
package. This command will interactively walk you through package creation,
collecting required inputs and asking you to choose from the available options.</p>
<pre class="shell"><code>$ mkdir flash-new-package

$ cd flash-new-package/

$ cabal init
What does the package build:
   1) Library
 * 2) Executable
   3) Library and Executable
   4) Test suite
...
Add informative comments to each field in the cabal file. (y/n)? [default: y]
[Log] Using cabal specification: 3.0
[Log] Creating fresh file LICENSE...
[Log] Creating fresh file CHANGELOG.md...
[Log] Creating fresh directory ./app...
[Log] Creating fresh file app/Main.hs...
[Log] Creating fresh file flash-new-package.cabal...
[Warning] No synopsis given. You should edit the .cabal file and add one.
[Info] You may want to edit the .cabal file and add a Description field.

$ tree .
.
├── app
│   └── Main.hs
├── CHANGELOG.md
├── flash-new-package.cabal
└── LICENSE</code></pre>
<p>Stack bundles <a href="https://github.com/sol/hpack">hpack</a>. This is a package description file generator that
generates a <code>.cabal</code> file from a <code>package.yaml</code>. This is similar to the <code>.cabal</code>
description except that it used different names for some fields (different
phraseology) and can infer some fields (detecting modules from disk) and expand
on terser values. The <code>hpack</code> command can be used standalone and there is a
similar <code>dhall-hpack-cabal</code> command that takes its import from a <code>package.dhall</code>
file. Ultimately Stack deals with the <code>.cabal</code> file whether it is generated or
not, the same way Cabal does, as the package description.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>We recommend using GHCup to install <code>cabal</code> so it is best not to also
install it yourself by other means unless you intend to hack on Cabal.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
            <hr />
            <footer>
                <div class="row">
    <div class="col-6">
        <i class="fab fa-github"></i>
        <a href="https://github.com/haskell/cabal" target="_blank" rel="noopener">github/haskell/cabal</a>
    </div>
    <div class="col-6">
        <img style="position:relative;top:-2px" src="https://hackage.haskell.org/static/favicon.png" width="14px" height="14px" />
        <a href="https://hackage.haskell.org/" target="_blank" rel="noopener">hackage</a><br />
    </div>
</div>

            </footer>
        </div>
    </div>
    <div class="d-none d-lg-block">
        <div class="fluid-container">
            <div class="row">
                <div id="nav-side" class="col-2 card d-print-none">
                    <div class="card-body">
    <h1 class="card-title" title="Cabal"><a href="./"><img id="img-logo" src="./images/Cabal-light.png" style="width:80%"></a></h1>

    <nav>
        <ul class="nav flex-column">
            <li class="nav-item"><a class="nav-link" href="http://cabal.readthedocs.io/en/latest/" target="_blank">
                    <i class="fa fa-book"></i>
                    docs</a></li>
            <li class="nav-item"><a class="nav-link" href="./pages/download.html">
                    <i class="fa fa-download"></i>
                    download</a></li>
            <li class="nav-item"><a class="nav-link" href="./releases/">
                    <i class="fa fa-calendar"></i>
                    releases</a></li>
            <li class="nav-item"><a class="nav-link" href="./pages/faq.html">
                    <i class="fa fa-question-circle"></i>
                    FAQ</a></li>
            <li class="nav-item"><a class="nav-link" href="./blog/">
                    <i class="fa fa-pen-nib"></i>
                    blog</a></li>
            <li class="nav-item"><a class="nav-link" href="./pages/history.html">
                    <i class="fa fa-clock-rotate-left"></i>
                    history</a></li>
        </ul>
    </nav>
    <div class="card">
        <div class="card-body">
            <span id="color-switch">set color&nbsp;<a class="link" id="btn-switch-color-mode">light</a></span>
        </div>
    </div>
</div>

                </div>
                <div id="content" class="d-print-col-12">
                    <h2 id="introduction">Introduction</h2>
<p>Cabal is an acronym of <strong>C</strong>ommon <strong>A</strong>rchitecture for <strong>B</strong>uilding
<strong>A</strong>pplications and <strong>L</strong>ibraries. Central to this architecture is <code>cabal</code>, the
executable (exe) build tool from the <a href="https://hackage.haskell.org/package/cabal-install">cabal-install</a> package.</p>
<div class="info">
<p>This architecture defines a common interface for package authors and
distributors to easily build their applications in a portable way. It is part of
a larger infrastructure for distributing, organizing, and cataloging Haskell
libraries and programs. Specifically, it describes what a package is, how these
interact with the language, and what Haskell implementations (compilers) must to
do to support packages. It also specifies some infrastructure (code) that makes
it easy for tool authors to build and distribute conforming packages.</p>
</div>
<p>Here's an elided dump of <code>cabal --help</code> showing the fundamental commands:</p>
<pre class="shell"><code>$ cabal --help
Command line interface to the Haskell Cabal infrastructure.

Commands:
 [initialization and download]
  init                   Create a new cabal package.

 [project building and installing]
  build                  Compile targets within the project.
  clean                  Clean the package store and remove temporary files.

 [running and testing]
  repl                   Open an interactive session for the given component.
  run                    Run an executable.
  test                   Run test-suites.

 [sanity checks and shipping]
  sdist                  Generate a source distribution file (.tar.gz).</code></pre>
<div class="warning">
<p>The architecture says nothing about more global issues such as how authors
decide where in the module name space their library should live; how users can
find a package they want; how orphan packages find new owners; and so on.</p>
</div>
<h2 id="packages">Packages</h2>
<p>When developing anything non-trivial in Haskell, anything that larger than a
single <code>.hs</code> file, we pack modules (<code>.hs</code> files) into packages.</p>
<ul>
<li><strong>Module</strong> - The unit of compilation in Haskell is the module. A module is a
collection of related functions, types, and type classes. Modules are the
primary unit of organization in Haskell programs.</li>
<li><strong>Package</strong> - The unit of distribution in Haskell is the package. A package is
a collection of one or more modules, plus some metadata about the package
(e.g., its name, version, and dependencies). Package components include
libraries, executables, test suites and benchmarks.</li>
</ul>
<p>Package source code can be published to Hackage and vetted by Stackage.</p>
<ul>
<li><p><strong>Hackage</strong> - A central repository of Haskell packages. Hackage is a website
that hosts packages and provides tools for searching, browsing, and
downloading packages.</p></li>
<li><p><strong>Stackage</strong> - For each resolver Stackage pairs a GHC compiler version with a
groups of packages from Hackage that build together. This group is pins each
included package to an exact version.</p>
<p>Stackage resolvers come in three sets; <code>nightly-yyyy-mm-dd</code> for the latest
set, <code>lts-mm.nn</code> for stable packages and <code>ghc</code> for the very limited set of
packages released with GHC. Each <code>lts-mm.*</code> series imposes some rules on
included packages, such as not allowing breaking version bumps.</p></li>
</ul>
<h2 id="demo">Demo</h2>
<p>Having installed <code>GHC</code> and <code>cabal</code> with <a href="https://www.haskell.org/ghcup/">GHCup</a> on Ubuntu Linux, let's
find <code>cabal</code>;</p>
<pre class="shell"><code>$ type cabal
cabal is ~/.ghcup/bin/cabal

$ readlink ~/.ghcup/bin/cabal
cabal-3.10.3.0

$ type cabal-3.10.3.0
cabal-3.10.3.0 is ~/.ghcup/bin/cabal-3.10.3.0</code></pre>
<p>We can use <code>cabal</code> to download its own package, <code>cabal-install</code>, from Hackage.</p>
<div class="info">
<p>A package is its description, in a <code>.cabal</code> file, and all of the source referred
to by that description. The package description file name must be the same as
the name of the package. An <code>sdist</code> is a <code>.tar.gz</code> archive of a package.</p>
</div>
<pre class="shell"><code>$ VER=3.10.3.0 cabal get cabal-install-{$VER}
Downloading  cabal-install-3.10.3.0
Downloaded   cabal-install-3.10.3.0
Unpacking to cabal-install-3.10.3.0/

$ VER=3.10.3.0 cat cabal-install-{$VER}/cabal-install.cabal
Cabal-Version:      2.2
Name:               cabal-install
Version:            3.10.3.0
...
executable cabal
...</code></pre>
<p>We can install <code>cabal</code> it again<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>, showing that <code>cabal</code> can build and install
local packages from source and when doing so downloads dependencies from
Hackage, in this case <code>cabal-install-solver</code> and <code>hackage-security</code>.</p>
<div class="info">
<p>We can (and oftentimes must) use <a href="https://cabal.readthedocs.io/en/latest/cabal-commands.html#target-forms">targets</a> to specify some or all
of the components of a package. Many <code>cabal</code> build tool commands require a
target and in fact, <code>cabal build</code> will fail if not given a target.</p>
<ul>
<li>The <code>all</code> target includes every component.</li>
<li>The <code>all:ctype</code> target includes every component of a certain component type
(<code>ctype</code>), such as <code>libs</code>, <code>exes</code> and <code>tests</code>.</li>
<li><code>cabal-install:exe:cabal</code> is a fully qualified name for <code>cabal</code>, as an <code>exe</code>
component of the <code>cabal-install</code> package.</li>
</ul>
</div>
<pre class="shell"><code>$ cd cabal-install-3.10.3.0/

$ cabal install cabal-install:exe:cabal --overwrite-policy=always
Wrote tarball sdist to
/.../cabal-install-3.10.3.0/dist-newstyle/sdist/cabal-install-3.10.3.0.tar.gz
Resolving dependencies...
Build profile: -w ghc-9.8.2 -O1
In order, the following will be built (use -v for more details):
 - cabal-install-solver-3.10.3.0 (lib) (requires download &amp; build)
 - hackage-security-0.6.2.6 (lib) (requires build)
 - cabal-install-3.10.3.0 (lib) (requires build)
 - cabal-install-3.10.3.0 (exe:cabal) (requires build)
Downloading  cabal-install-solver-3.10.3.0
Starting     hackage-security-0.6.2.6 (lib)
Downloaded   cabal-install-solver-3.10.3.0
Starting     cabal-install-solver-3.10.3.0 (lib)
Building     hackage-security-0.6.2.6 (lib)
Building     cabal-install-solver-3.10.3.0 (lib)
Installing   hackage-security-0.6.2.6 (lib)
Completed    hackage-security-0.6.2.6 (lib)
Installing   cabal-install-solver-3.10.3.0 (lib)
Completed    cabal-install-solver-3.10.3.0 (lib)
Starting     cabal-install-3.10.3.0 (lib)
Building     cabal-install-3.10.3.0 (lib)
Installing   cabal-install-3.10.3.0 (lib)
Completed    cabal-install-3.10.3.0 (lib)
Starting     cabal-install-3.10.3.0 (exe:cabal)
Building     cabal-install-3.10.3.0 (exe:cabal)
Installing   cabal-install-3.10.3.0 (exe:cabal)
Completed    cabal-install-3.10.3.0 (exe:cabal)
Symlinking 'cabal' to '~/.cabal/bin/cabal'</code></pre>
<div class="warning">
<p>There is currently no command to show the available targets, but <code>cabal targets</code>
has been proposed for this purpose with <a href="https://github.com/haskell/cabal/pull/9744">cabal#9744</a>.</p>
</div>
<h2 id="projects">Projects</h2>
<p>Even larger, projects are a collections of packages. These allow us to develop a
set of related packages, to develop a product and to depend on unpublished
packages that we can get from source code repositories or other means.</p>
<ul>
<li><strong>Source Code Repositories</strong> - It is possible to depend on packages that are
in a source code repository.</li>
<li><strong>Vendored Packages</strong> - When source code for a package is copied locally and
used if it was a local package.</li>
</ul>
<h2 id="building-with-stackage">Building with Stackage</h2>
<p>There are two main build tools in the Haskell ecosystem, Cabal and Stack with
exe names <code>cabal</code> and <code>stack</code>. The main difference between them is how they deal
with dependencies in their projects. Stack works with a Stackage resolver and
any dependency that is not included in the resolver must be pinned to an exact
version as an extra dependency. Cabal can work this way too but has a built-in
dependency solver that will pick versions of dependencies that are not pinned,
if it can.</p>
<p>Stack's project is a <code>.yaml</code> file and Cabal's is a <code>.project</code> file (by
convention). Each tools' command allows specifying alternate projects with
options, shown below specifying the default project names.</p>
<ul>
<li><code>--stack-yaml=stack.yaml</code></li>
<li><code>--project-file=cabal.project</code></li>
</ul>
<p>Both tools will pick up the project implicitly if it uses the default project
file name.</p>
<div class="info">
<p>Everything in a Stack project must be in the one file. That's a limitation of
<code>YAML</code>. The <code>.project</code> file format has no formal specification but uses the same
parser as the <code>.cabal</code> format that does, reusing some of the same fields as well
as having some fields specific to a project. The <code>import</code> field can be used to
import another project file configuration fragment and this is how Cabal can use
Stackage resolvers.</p>
<pre class="cabal"><code>import: https://www.stackage.org/nightly-2024-06-13/cabal.config</code></pre>
<pre class="shell"><code>$ curl -fsSL https://www.stackage.org/nightly-2024-06-13/cabal.config
...
with-compiler: ghc-9.8.2
constraints: abstract-deque ==0.3,
             abstract-deque-tests ==0.3,
             abstract-par ==0.3.3,
...
             zlib-clib ==1.3.1,
             zot ==0.0.3,
             zstd ==0.1.3.0</code></pre>
</div>
<div class="warning">
<p>While importing directly from Stackage may work, it can lead to unsolveable
version constraints. The way around this is to download the <code>cabal.config</code> from
Stackage for the resolver you want to use and then to comment out any
conflicting version constraints.</p>
</div>
<div class="warning">
<p>While Stack can work with Stackage <code>ghc-x.y.z</code> resolvers, no such resolver is
provided in <code>cabal.config</code> (cabal project) format.</p>
<pre class="shell"><code>$ curl -fsSL https://www.stackage.org/ghc-9.8.2/cabal.config
curl: (22) The requested URL returned error: 404</code></pre>
</div>
<h2 id="building-without-stackage">Building without Stackage</h2>
<p>A Cabal project can be set up without importing constraints from Stackage. If
you encounter constraint solver failures then picking a subset of a Stackage
resolvers' version constraints may help resolve the problem quicker than
fiddling with version choices and <code>allow-newer</code> exeptions until the constraint
solver is happy.</p>
<h2 id="extra-dependencies">Extra Dependencies</h2>
<p>Extra dependencies are a Stack concept that doesn't really exist in Cabal.
These are exact versions of packages that a project depends on that are not
included with the resolver in use (<code>snapshot</code> is a synonym of <code>resolver</code>). Here
are Stack's own extra dependencies:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">snapshot</span><span class="kw">:</span><span class="at"> lts-22.21</span><span class="co"> # GHC 9.6.5</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">extra-deps</span><span class="kw">:</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="co">  # lts-22.21 provides pantry-0.9.3.2.</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> pantry-0.10.0@sha256:6f99ee8d7cfeeb0e2513638618acf80c72d018e7f10120048fa120a409b9dcd2,7864</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="co">  # lts-22.21 provides tar-0.5.1.1, which does not support Unicode filenames:</span></span>
<span id="cb8-6"><a href="#cb8-6" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> tar-0.6.2.0@sha256:619828cae098a7b6deeb0316e12f55011101d88f756787ed024ceedb81cf1eba,4576</span></span></code></pre></div>
<div class="info">
<p>If you're committing the <code>stack.yaml.lock</code> file then it is enough to leave off
the hash as the <code>.lock</code> file contains that detail. This way we can see that
Stack's <code>extra-deps</code> are exact version equality constraints.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">extra-deps</span><span class="kw">:</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> pantry-0.10.0</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> tar-0.6.2.0</span></span></code></pre></div>
</div>
<p>The same exact version equality constraints in a <code>cabal.project</code> would be:</p>
<pre class="cabal"><code>constraints:
    pantry ==0.10.0
  , tar ==0.6.2.0</code></pre>
<p>Stack needs these versions to be explicitly declared but Cabal will use its dependency
solver to fill in the gaps.</p>
<p>Whether using Stack or Cabal, the versions of dependencies needs to fit within
the version ranges for dependencies as specified in the <code>build-depends</code> field of
the package description. There is a way of relaxing the version constraints with
<code>--allow-newer</code> but this should only be used as a temporary workaround in order
to get a project to build. If there's a version range bound problem with a
dependency then you may fork it and fix the problem there (and hopefully
upstreaming the change) or you can ask the maintainer for a Hackage revision of
the package to relax an upper bound.</p>
<h2 id="source-dependencies">Source Dependencies</h2>
<p>From this snippet of a <code>cabal.project</code> for
<a href="https://github.com/up-do/unison/blob/add/updo/cabal.project">unison/cabal.project</a>, we can see that it is possible to
pull in dependencies from a source code repository (in addition to some version
constraints) with <code>source-repository-package</code> stanzas.</p>
<pre class="cabal"><code>import: ./project-stackage/lts-20.26.config

source-repository-package
  type: git
  location: https://github.com/unisonweb/configurator
  tag: e47e9e9fe1f576f8c835183b9def52d73c01327a
source-repository-package
  type: git
  location: https://github.com/unisonweb/haskeline
  tag: 9275eea7982dabbf47be2ba078ced669ae7ef3d5</code></pre>
<p>The Stack equivalent is very similar:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">resolver</span><span class="kw">:</span><span class="at"> lts-20.26</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">extra-deps</span><span class="kw">:</span></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">git</span><span class="kw">:</span><span class="at"> https://github.com/unisonweb/configurator</span></span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> e47e9e9fe1f576f8c835183b9def52d73c01327a</span></span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a><span class="at">  </span><span class="kw">-</span><span class="at"> </span><span class="fu">git</span><span class="kw">:</span><span class="at"> https://github.com/unisonweb/haskeline</span></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="at">    </span><span class="fu">commit</span><span class="kw">:</span><span class="at"> 9275eea7982dabbf47be2ba078ced669ae7ef3d5</span></span></code></pre></div>
<h2 id="package-and-description-generators">Package (and Description) Generators</h2>
<p>Starting with a blank slate, <code>cabal init</code> can be used to generate a skeleton
package. This command will interactively walk you through package creation,
collecting required inputs and asking you to choose from the available options.</p>
<pre class="shell"><code>$ mkdir flash-new-package

$ cd flash-new-package/

$ cabal init
What does the package build:
   1) Library
 * 2) Executable
   3) Library and Executable
   4) Test suite
...
Add informative comments to each field in the cabal file. (y/n)? [default: y]
[Log] Using cabal specification: 3.0
[Log] Creating fresh file LICENSE...
[Log] Creating fresh file CHANGELOG.md...
[Log] Creating fresh directory ./app...
[Log] Creating fresh file app/Main.hs...
[Log] Creating fresh file flash-new-package.cabal...
[Warning] No synopsis given. You should edit the .cabal file and add one.
[Info] You may want to edit the .cabal file and add a Description field.

$ tree .
.
├── app
│   └── Main.hs
├── CHANGELOG.md
├── flash-new-package.cabal
└── LICENSE</code></pre>
<p>Stack bundles <a href="https://github.com/sol/hpack">hpack</a>. This is a package description file generator that
generates a <code>.cabal</code> file from a <code>package.yaml</code>. This is similar to the <code>.cabal</code>
description except that it used different names for some fields (different
phraseology) and can infer some fields (detecting modules from disk) and expand
on terser values. The <code>hpack</code> command can be used standalone and there is a
similar <code>dhall-hpack-cabal</code> command that takes its import from a <code>package.dhall</code>
file. Ultimately Stack deals with the <code>.cabal</code> file whether it is generated or
not, the same way Cabal does, as the package description.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>We recommend using GHCup to install <code>cabal</code> so it is best not to also
install it yourself by other means unless you intend to hack on Cabal.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
                    <hr />
                    <footer>
                        <div class="row">
    <div class="col-6">
        <i class="fab fa-github"></i>
        <a href="https://github.com/haskell/cabal" target="_blank" rel="noopener">github/haskell/cabal</a>
    </div>
    <div class="col-6">
        <img style="position:relative;top:-2px" src="https://hackage.haskell.org/static/favicon.png" width="14px" height="14px" />
        <a href="https://hackage.haskell.org/" target="_blank" rel="noopener">hackage</a><br />
    </div>
</div>

                    </footer>
                </div>
            </div>
        </div>
    </div>
    <script>
        var switchColor = () => {
            if (document.documentElement.getAttribute('data-bs-theme') == 'dark') {
                document.getElementById('btn-switch-color-mode').innerHTML = 'light'
                document.getElementById('img-logo').setAttribute('src','/images/Cabal-dark.png')
            }
            else {
                document.getElementById('btn-switch-color-mode').innerHTML = 'dark'
                document.getElementById('img-logo').setAttribute('src','/images/Cabal-light.png')
            }
        };

        document.getElementById('btn-switch-color-mode').addEventListener('click',()=>{
            if (document.documentElement.getAttribute('data-bs-theme') == 'dark') {
                document.documentElement.setAttribute('data-bs-theme','light')
            }
            else {
                document.documentElement.setAttribute('data-bs-theme','dark')
            }

            switchColor();
        })

        switchColor();
    </script>
</body>

</html>
